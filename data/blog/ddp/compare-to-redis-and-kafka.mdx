---
title: Redis vs Kafka Pub/Sub
date: '2024-02-15'
tags: ['redis', 'kafka']
draft: false
summary: redis와 kafka를 pub/sub 비교
---

<TOCInline toc={props.toc} toHeading={4} />

---

## 게시/구독(Publish/Subscribe) 메시징

현대의 클라우드 아키텍처에서는 애플리케이션을 더 작고 독립적인 블록으로 분리하는 추세(**SOA or MSA**)  
이러한 분산 시스템에서는 실시간 이벤트 알림(**게시/구독(pub/sub) 메시징**)이 중요한 역할을 한다.  
`메시징 시스템을 구축`하는 데 있어 `Kafka와 Redis는` 두 가지 주요 대안으로 떠올랐다.

---

## redis

`Redis`는 In-memory key-value 데이터 스토어로 이벤트 발생 시   
게시자가 모든 구독자에게 메시지를 배포하는 `푸시 기반 시스템`을 지원한다.

[redis 내용 정리](/blog/about-redis)

## apache kafka

`Kafka`는 스트림 처리 엔진으로 게시자와 구독자가 공통 메시지 대기열을 공유하여  
구독자가 필요에 따라 메시지를 가져오는 `풀 기반 시스템`을 지원한다.

[Kafka 내용 정리](/blog/about-apache-kafka)

---

## Redis, Kafka 차이

### 작동 방식

- **redis의 작동방식(워크플로우) 요약**

  1. Redis는 `인 메모리 데이터베이스`로, `클라이언트-서버 아키텍처`를 사용한다.
  2. 생산자와 소비자는 서로 긴밀하게 연결되어 있으므로 메시지를 보낼 때 서로를 알 필요가 없다.
  3. 키와 기본-보조 노드를 사용하여 메시지를 그룹화하고 복제한다.
  4. 생산자가 메시지를 보내면 Redis는 해당 메시지 키를 확인하여 연결된 모든 가입자에게 메시지를 전달한다.
  5. 소비자는 메시지를 수신하기 위해 Redis 서버와의 활성 연결을 유지해야 하며, 이를 `연결된 전송 체계`로 구현한다.

- **kafka의 작동방식(워크플로우) 요약**

  1.  Kafka는 이벤트 스트리밍 플랫폼으로, 여러 애플리케이션 간에 데이터를 스트리밍한다.
  2.  클러스터를 통해 브로커들이 연결되어 있으며, 각 브로커는 다른 서버에 위치한다.
  3.  주제와 파티션을 생성하여 데이터를 그룹화하고, 파티셔닝을 통해 데이터를 분산 및 복제하여 내결함성을 보장한다.
  4.  생산자는 브로커에게 메시지를 게시하고, 브로커는 해당 메시지를 주제에 분류하고 파티션에 저장힌다.
  5.  소비자는 주제에 연결하여 해당 파티션에서 데이터를 추출한다.

### 메시지 처리

**1. 메시지 크기**

- **Redis**: Redis는 RAM이 디스크 저장소보다 작은 용량을 가지고 있기 때문에 대량의 데이터를 저장할 수 없어 대용량 데이터 처리보다는 `작은 크기의 데이터 패킷 전송`에 적합하다.
- **Kafka**: Kafka는 압축 및 계층형 스토리지를 구성하여 `최대 1GB의 메시지 처리`가 가능하다.

**2. 메시지 전송**

- **Redis**: 메시지를 구독자에게 `자동으로 전송`한다. 구독자는 서버에서 수신되는 메시지를 수동적으로 기다리며 최대 1회 전송으로 설정되었으므로 Redis 구독자는 `중복 메시지를 감지할 수 없다`.
- **Kafka**: `구독자(=소비자)가 메시지 큐에서 데이터를 가져온다`. Kafka 소비자는 `오프셋을 사용`하여 읽은 `메시지를 추적`하며, `중복 메시지를 감지`할 수 있다.

**3. 메시지 보존**

- **Redis**: 메시지를 전달한 후에는 `메시지를 보존하지 않는다`. Redis는 스트림에 연결된 구독자가 없으면 메시지를 삭제하며 구족자가 나중에 연결해도 삭제된 메시지는 복구할 수 없다.
- **Kafka**: 소비자가 메시지를 읽은 후에도 `메시지를 보존한다`. 클라이언트 애플리케이션이 검색한 데이터를 잃어도 해당 데이터를 해당 파티션에서 다시 요청할 수 있다.

**4. 오류 처리**

- **Redis**:
  1. `클라이언트 응용 프로그램`과 `레디스 서비스`간의 `상호 작용에 중점`을 둔다.
  2. 메모리 버퍼 초과, 클라이언트 제한 등의 상황에 대응할 수 있지만 `메시지 오류 처리에는 제한적`이다.
     > 제한 시간, 클라이언트 제한 및 메모리 버퍼 용량을 사용하여 애플리케이션 수준에서 redis 예외를 처리해야 한다.
- **Kafka**:
  1. 메시징 수준에서 강력한 오류 처리
  2. 전달하지 못한 메시지 대기열
     > 오류 이벤트를 `데드 레터 큐에 저장`하거나 `재시도`하여 `일관된 메시지 전달을 가능`하게 한다. `Kafka Connect API`를 사용하여 `특정 오류에서 자동으로 커넥터 작업`을 다시 시작할 수 있다.
  3. 이벤트 재시도 및 리다이렉션

### 성능

**1. 병렬 처리**

- **Redis**: `병렬 처리를 지원하지 않는다`.
- **Kafka**: 동일한 메시지를 여러 소비자에게 동시에 검색할 수 있어 `병렬 처리가 가능`하다.

**2. 처리량**

- **Redis**: `연결된 노드가 많을수록 처리량이 감소`한다.
  > redis 서버가 다른 구독자에게 메세지를 보내기 전 회신을 기다려야 하기 떄문에 처리량이 줄어든다.
- **Kafka**: `비동기 읽기/쓰기`로 일반적으로 `Redis보다 높은 처리량`을 보인다.

**3. 지연 시간**

- **Redis**: 작은 크기의 메시지를 전송할 떄 밀리초 단위의 `낮은 메시징 시간을 제공`한다.
- **Kafka**: 메시징 시간은 평균 수십 밀리초이며, 데이터 지속성(데이터 복제)을 위해 `오버헤드가 발생`할 수 있다.

**4. 내결함성**

- **Redis**:
  - `기본적으로 데이터를 백업하지 않는다.`
  - `지속성을 위해 수동으로 활성화`하여 데이터 스냅샷을 주기적으로 캡처하여 디스크에 저장할 수 있다.
  - `소규모 데이터 손실 위험`이 있다.
- **Kafka**: 모든 데이터를 주요 브로커의 스토리지 디스크에 쓰고 `여러 서버(브로커)에 복제(백업)하여 내결함성을 제공`한다.

### 사용시기

그렇다면 redis와 kafka는 언제 사용하면 될까?

**Redis**

- 즉각적인 데이터 전송이 필요하고 데이터 손실이 적은 애플리케이션을 위해 지연시간이 매우 짧은 이벤트 베포를 제공
- 자주 엑세스하는 데이터를 저장
- 긴급 메시지를 전달하는 세션 캐시(session cache)로 사용
- e-commerce 또는 SNS 데이터를 저장하여 원활한 UX를 제공하는데 적합

**Kafka**:

- 대규모 데이터 세트를 스트리밍하고 높은 복구 성능이 필요한 애플리케이션을 구축하는데 적합
- 단일 분산 데이터 파이프라인
- 여러 서버에 파티션을 복제하여 노드 장애 시 데이터 소실을 방지
- 애플리케이션, Iot장치, 마이크로서비스 간의 실시간 통신 지원
- 로그 집계, 스트림 처림, 클라우드 기반 데이터 통합 작업에 적합
